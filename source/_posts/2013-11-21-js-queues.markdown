---
layout: post
title: "[JS] Stacks, Queues, Class Patterns, & Batman"
date: 2013-11-21 19:11
comments: true
categories: ['JavaScript','Hack Reactor','JS']
---

INTRO PARAGRAPH

# What's a Stack?

A stack is a collection of items (pieces of data) that follow a particular rule: the last item to join the collection is the first one to leave.

- The **L**ast data **I**n is the **F**irst data **O**ut (**LIFO**)
- Add data: **push**
- Remove data: **pop**
- Data enters and exits at the same end of the stack (at the **top**)

## Simple implementation

{% coderay Simple Stack (array-based example) lang:javascript http://stackoverflow.com/questions/1590247/how-do-you-implement-a-stack-and-a-queue-in-javascript Stack Overflow %}
var stack = [];
stack.push(1);  // use the push method provided by the Array prototype
stack.push(2);
stack.push(3);
console.log(stack);  // output: [1,2,3]

stack.pop();  // use the pop method provided by the Array prototype
console.log(stack);  // output: [1,2]
{% endcoderay %}

## Ridiculous analogy

Imagine you've found an old, abandoned well. You think to yourself, "Bruce Wayne fell down a well when he was a kid, and I wanna be just like the Batman, so I'm gonna fall down this sweet well!" But you hesitate because it's a deep well.

Your arch-nemesis is walking her pet hyena. She spots you, and quickly runs over to shove you into the well. She then hides and waits for more people to walk near the well so she can **push** them too.

It just so happens that this well has the diameter of a single person. When someone is pushed into the well, they land on top of the last person who fell in before them. This creates a **stack** of people, and some rather pronounced discomfort. Eventually, there are 5 people in this deep-yet-thin well, and you decide it's time to call for help to get rescued.

To your disappointment, the not-so-dark knight named Superman arrives to pull you well-dwellers out (one at a time). The last one pushed into the well is the first to **pop** out. *LIFO.*

{% blockquote Dexter Pennyworth (Alfred's programmer cousin)  %}
Why do we fall?
So we can simulate the data structure known as a stack. Duh.
{% endblockquote %}

# What's a Queue?

A queue is a collection of items (pieces of data) that follow the real-life "rules" about waiting in a line of people: the first item to join the collection is the first one to leave the collection.

- The **F**irst data **I**n is the **F**irst data **O**ut (**FIFO**)
- Add data: **enqueue**
- Remove data: **dequeue**
- Data exits at the: **head** of the queue
- Data enters at the: **tail** of the queue

## Simple implementation

{% coderay Simple Queue (array-based example) lang:javascript http://stackoverflow.com/questions/1590247/how-do-you-implement-a-stack-and-a-queue-in-javascript Stack Overflow %}
var queue = [];
queue.push(1);  // "enqueue"
queue.push(2);
queue.push(3);
console.log(queue);  // output: [1,2,3]

queue.shift();  // "dequeue"
console.log(queue);  // output: [2,3]
{% endcoderay %}

## Ridiculous analogy

Batman decides to do some in-the-field combat training. He drops into the middle of a gang meeting and yells, "I've sent your buddies to jail. I know you want revenge. Catch me if you can." We all know Batman is a smart dude, and sure enough, he has a clever plan. He lures the baddies who are running after him in a narrow alley.

The gangsters can only approach Batman one at a time to fit in the narrow alley, so they form a line (aka **queue**). The gangster at the front of the line is the first gangster knocked out (aka **dequeued**) by Batman (**first in; first out**). You might even say that Batman's fists aim for the **head** of the queue and foolish gangsters enter the line of doom at the **tail** of the queue.

# Class Patterns

## 1. Functional Instantiation

The simplest way to implement classes is with a "maker" function that creates a new instance of the class and returns that instance so it can be stored as a variable. The new instance is just like any other JavaScript object. It can have properties that store relevant information about the instance (e.g., with a `Car` class, instances might have a `color` property). It can also have properties that store functions. These functions serve as **methods** because they are tightly associated with the instance.

#### Characteristics

- Creates new copies of the same functions when creating a new instance of the same class. This lack of reuse takes up more memory.
- Modifying the class does not modify instances of the class.
- Private variables can be created/used by harnessing **closure scope** superpowers.
- If you understand JavaScript functions and objects, then you can understand classes implemented via functional instantiation (other instantiation techniques require knowledge of `this` and/or `new`).
- Could be used to create callable instances (i.e., the class could return a function rather than an object filled with properties).

#### Example code:
{% coderay Stack from scratch (functional instantiation) lang:javascript %}
var makeStack = function(comment){
  // Provide private variables in closure scope
  var size = 0;
  var storage = {};
  var instance = {};  // Start building an instance of Stack class

  // Add extra properties if you want to (or don't, I'm a comment, not a cop)
  instance.annotation = comment;

  // Add functions to the instance to serve as methods
  // (they will provide an interface to the stack's storage)
  instance.push = function(data){
    storage[size] = data;
    size++;
  };

  instance.pop = function(){
    if(size > 0){  // Only perform pop actions if the stack has data
      size--;
      var data = storage[size];
      delete storage[size];  // Don't forget to delete from storage!
      return data;
    }
  };

  instance.size = function(){
    return size;
  };

  return instance;
};

// Create and use an instance of the Stack class
var myStack = makeStack("I'm a stack! Whoa.");
myStack.push(1);              // myStack stores 1
myStack.push('b');            // myStack stores 1 and 'b'
myStack.push(3);              // myStack stores 1, 'b', and 3
console.log(myStack.pop());   // logs 3
console.log(myStack.size());  // logs 2
{% endcoderay %}

## 2. Functional Instantiation with Shared Methods

By utilizing an object filled with methods, several classes can be created that have the same methods without creating new copies of said methods. The classes will use their own function references to refer to the same set of shared methods. Therefore, using shared methods uses less memory than functional instantiation *without* shared methods.

#### Characteristics

- Reuses functions (which conserves memory) by getting function references from a utility such as [Underscore.js](http://underscorejs.org/#extend)'s `_.extend(instance,methods)`.
- Retains the same benefits as functional instantiation *without* shared methods.

#### Example code:
{% coderay Queue from scratch (functional instantiation with shared methods) lang:javascript %}
var makeQueue = function(queueName, comment){
  
  // Don't forget you can use object literal notation
  // instead of dot notation (if you want to)
  var instance = {
    name: queueName,
    annotation: comment,
    head: 0,
    tail: 0,
    storage: {}
  };
  
  // _.extend() provided by library (Underscore.js)
  _.extend(makeQueue, sharedQueueMethods); 
  
  return instance;
};

// The object below stores methods that could be shared with other classes
var sharedQueueMethods = {
  enqueue: function(data){
    this.storage[this.tail] = data;
    this.tail++;
    // The tail points to the next EMPTY "spot" for data to be stored
    // it does NOT point to the last OCCUPIED "spot" in the storage
  },
  dequeue: function(){
    if(this.head <= this.tail){  // Check the queue's size
      var data = this.storage[this.head];

      // Deleting is even more important for queues than for stacks
      // (memory leaks are a bigger threat for queues)
      delete this.storage[this.head];
      this.head++;
      return data;
    }
  },
  size: function(){
    return this.tail - this.head;
  }
};

// Create and use an instance of the Queue class:
var myCoolQueue = makeQueue("Jeff's Queue",'Hello, world!');
myCoolQueue.enqueue('a');             // myCoolQueue stores 'a'
myCoolQueue.enqueue(2);               // myCoolQueue stores 'a' and 2
myCoolQueue.enqueue('c');             // myCoolQueue stores 'a', 2, and 'c'
console.log(myCoolQueue.dequeue());   // output: 'a'
console.log(myCoolQueue.size());      // output: 2
{% endcoderay %}

## 3. Prototypal Instantiation

The key to prototypal instantiation is the use of `Object.create()` to utilize shared methods. Unlike functional instantiation with shared methods, there is no need to use an `extend()` function.

While it's possible to use a prototype's functions with `Object.create(ExampleClass.prototype);`, it's also possible to (ironically) avoid the word "prototype" altogether by using `Object.create(sharedMethods);`.

#### Characteristics

- Reuses shared functions via `Object.create(foo.prototype)`.
- Unlike functional instantiation, function references are shared. Each instance of the class does not get its own function references that point to the shared methods. This saves even more memory (although it is a very small improvement).
- Can use prototype chains for dynamic method modification and inheritance (subclasses!).

#### Example code:
{% coderay Stack from scratch (prototypal instantiation) lang:javascript %}
var makeStack = function(comment){
  var instance = Object.create(sharedStackMethods);
  instance.annotation = comment;
  instance.size = 0;
  instance.storage = {};

  return instance;
};

var sharedStackMethods = {
  push: function(data){
    this.storage[this.size] = data;
    this.size++;
  },
  pop: function(){
    if(this.size > 0){
      this.size--;
      var data = this.storage[this.size];
      delete this.storage[this.size];
      return data;
    }
  },
  size: function(){
    return this.size;
  }
};

// Create an instance of the Stack class:
var myStack = makeStack("I'm a stack! Whoa.");
// Using the instance doesn't change from one class pattern to another
myStack.push(1);              // myStack stores 1
myStack.push('b');            // myStack stores 1 and 'b'
myStack.push(3);              // myStack stores 1, 'b', and 3
console.log(myStack.pop());   // logs 3
console.log(myStack.size());  // logs 2
{% endcoderay %}

## 4. Pseudoclassical Instantiation

This is the most commonly used class pattern. It's also the most complicated because it involves three concepts that the other class patterns don't need: the `this` keyword, the `new` keyword, and prototypes. Furthermore, it's the only class pattern that uses a true [constructor](http://en.wikipedia.org/wiki/Constructor_(object-oriented_programming)) for creating new instances. Other class patterns use instantiator functions that explicitly return a new instance. The pseudoclassical class pattern does not perform such a return thanks to the `new` keyword.

#### Characteristics

- Uses prototype chains to provide methods to instances of a class.
- Allows for dynamic method modification and inheritance (subclasses!) via prototype chains.
- Refers to the instance being created with the `this` keyword.
- Needs the `new` keyword to make a new instance of a class.
- Has a true constructor that is named with a noun rather than a verb. The name is capitalized.
- Is the most commonly used class pattern.

#### Example code:
{% coderay Queue from scratch (pseudoclassical instantiation) lang:javascript %}
// Class name is now a noun (no verb), and it starts with an upper case letter
var Queue = function(queueName, comment){ 
  // Notice the use of `this`
  this.name = queueName,
  this.annotation = comment,
  this.head: 0,
  this.tail: 0,
  this.storage: {}
};

// Notice the use of `prototype`
Queue.prototype.enqueue = function(data){
  this.storage[this.tail] = data;
  this.tail++;
};
Queue.prototype.dequeue = function(){
  if(this.head <= this.tail){
    var data = this.storage[this.head];
    delete this.storage[this.head];
    this.head++;
    return data;
  }
};
Queue.prototype.size = function(){
  return this.tail - this.head;
};

// Create an instance of the Stack class by using the `new` keyword:
var myCoolQueue = new Queue("Jeff's Queue","The grass is always greener, but just as hard to mowww!");
// Use the instance just like in previous examples
myCoolQueue.enqueue('a');             // myCoolQueue stores 'a'
myCoolQueue.enqueue(2);               // myCoolQueue stores 'a' and 2
myCoolQueue.enqueue('c');             // myCoolQueue stores 'a', 2, and 'c'
console.log(myCoolQueue.dequeue());   // output: 'a'
console.log(myCoolQueue.size());      // output: 2
{% endcoderay %}
